Why build yet another operating system?
---------------------------------------

* Because it's fun (most important point!)
* To learn and improve
* To study algorithms and system design
* It's meditative
* To celebrate ARPANET 50 years

General
-------
DON'T IMPLEMENT GRAPHICS. It's a crazy rabbit hole of VESA, VBE3, VGA,
SVGA, etc. especially when the BIOS isn't used. Plus, I've already
played around a lot with graphics -- better to focus on networking
which has far better documentation.

Note: if I want to do graphics, I should probably use the multiboot
video feature. It's incredibly handy, if it works.

Try to make things as simple as possible when taking into account
current requirements -- not what might be needed in the future. Ie,
don't abstract out x86 until multi-platform is needed.

DON'T overthink naming. Ie, don't waste time thinking about "init" vs
"setup", verb-noun vs noun-verb, etc. It doesn't have to be
consistent.

Build and run
-------------
* Build the cross-compiler docker image in build/compiler
* Use build/build-shell to get a bash shell with the cross-compiler and run `make`
* Run with `run-qemu`

Unittests on host
-----------------
* ./run_unittests
* make -f Makefile.unittests clean

Notes
-----
* Kernel isn't started when constructors are run, only use them for trivial init
* IRQs are mapped to start at 0x20 (IRQ_BASE_INTERRUPT)
* The kernel starts with paging enabled and two identity mappings, one at 0x0, the other at 0xC0000000, with
  EIP being in the latter
* Everything is "work in progress" and you can expect iterations

Style
-----
* Internal structs/classes for a subsystem NO prefix (ie, GOOD: "process", "context".)
* External handle types YES prefix (ie, GOOD: "vfs_context", "mem_space")
* Handle variables, GOOD: "context_handle"
* Member variables, GOOD: "_member"
* To fix name collision, GOOD: "context &context_"

Plan
----
* DONE Basics (compiler, etc)
* DONE GDT
* DONE IRQs, INTs, keyboard
* DONE Ring 3 execution
* DONE Syscalls different CPL (Ring 3)
* DONE Simple VFS for device drivers (Syscalls)
* DONE Single screen terminal controllable from program through /dev/termN (VFS)
* DONE Multitasking
* DONE Preemptive multitasking, blocking calls, scheduling
* DONE Protected memory through paging + high mem kernel
* DONE Update syscalls to work with paging
* DONE Multi screen terminal (Terminal)
* DONE Some way to get a basic FS up with files/a ramdisk (user programs, text)
* DONE Improved memory protection with kernel memory marked for supervisor
* DONE TAR parsing for initial ramdisk
* DONE Start user process from binary on filesystem, ELF
* PCI device enumeration
* RTL8139 support
* Basic Ethernet
* User permissions in VFS
* SMP

Terminal emulation
------------------
At boot, a number of terminals are spawned and mapped to the F1-F12 keys.

Each terminal is controlled using a /dev/termN special file.

Each terminal gets a buffer.

/dev/termN is a stream of bytes "controlling" the terminal. Ie, bytes
should be seen as commands for the terminal to execute.

Special commands to the terminal (such as "move to x, y", "change
color", etc) use escape sequences similar to ANSI.

Special keys from the terminal (such as "left arrow") also use escape
sequences; no extra syscalls are needed to get the special keys.

keyboard.h -> terminal.h -> {user application -> terminal.h ->} screen.h
