#!/bin/bash
cd `dirname $0`

# Note that networking uses qemu's "user networking" mode rather than a TAP interface. I tried
# to get a TAP up and running on macOS, but bridging it with an Ethernet interface would cause
# consistent kernel panics (possibly in tuntaposx' kexts)
# User mode networking should also make it easier to run integration tests; fewer moving parts
# and no root access needed
# Traffic to and from the guest can be monitored in realtime using ./run-wireshark
# QEMU monitor can be connected to using ./connect-qemu-monitor

FLAGS="-d pcall,cpu_reset,guest_errors \
  -netdev user,id=mynet0,hostfwd=tcp::8884-:5555,hostfwd=udp::8884-:5555 \
  -device rtl8139,netdev=mynet0,mac=02:ca:fe:f0:0d:01 \
  -object filter-dump,id=dp1,netdev=mynet0,file=vm0.pcap"

INIT_SHELL="-initrd init.tar -append init=/ramfs/bin/shell"
UD_MONITOR="-monitor unix:/tmp/qemu-monitor,server,nowait"

case $1 in
  diskimage)
    qemu-system-i386 -s -drive format=raw,file=peos2.img -no-reboot -no-shutdown -monitor stdio $FLAGS
    ;;

  display)
    qemu-system-i386 -s -kernel kernel/vmpeoz -no-reboot -no-shutdown -monitor stdio $FLAGS $INIT_SHELL
    ;;

  debug)
    qemu-system-i386 -s -S -kernel kernel/vmpeoz -no-reboot -no-shutdown -monitor stdio $FLAGS $INIT_SHELL
    ;;

  test-tester)
    qemu-system-i386 -nographic -s -kernel kernel/vmpeoz -no-reboot $FLAGS -initrd init.tar -append init=/ramfs/bin/tester
    ;;

  test-shell)
    qemu-system-i386 -nographic -s -kernel kernel/vmpeoz -no-reboot $FLAGS $INIT_SHELL
    ;;

  test-cdrom)
    qemu-system-i386 -cdrom peos2.img -nographic -no-reboot -d pcall,cpu_reset,guest_errors
    ;;

  vnc)
    printf "change vnc password\n%s\n" password | qemu-system-i386 -s -vnc :0,password -kernel kernel/vmpeoz \
      -no-reboot -no-shutdown -$FLAGS -initrd init.tar -append init=/ramfs/bin/shell_launcher $UD_MONITOR
    ;;

  terminal)
    qemu-system-i386 -s ${EXTRA:-} -nographic -kernel kernel/vmpeoz $INIT_SHELL $FLAGS $UD_MONITOR
    ;;

  terminal-net)
    qemu-system-i386 -s ${EXTRA:-} -nographic -kernel kernel/vmpeoz -initrd init.tar -append init=/ramfs/bin/nsa $FLAGS $UD_MONITOR
    ;;

  httpd)
    FLAGS="-d pcall,cpu_reset,guest_errors \
      -netdev user,id=mynet0,hostfwd=tcp::${PORT:-8080}-:5555 \
      -device rtl8139,netdev=mynet0,mac=02:ca:fe:f0:0d:01 \
      -object filter-dump,id=dp1,netdev=mynet0,file=vm0.pcap"

    echo FLAGS=$FLAGS
    qemu-system-i386 -nographic -kernel kernel/vmpeoz -initrd init.tar -append init=/ramfs/bin/nsa $FLAGS
    ;;

  httpd-tap)
    # We "transplant" the NIC's hwaddr so that we pretend to be the
    # machine with that NIC. The qemu-ifup script makes sure that the
    # bridge will forward frames destined for that address
    EXT_IF=${BRIDGE_IF:-eth0}
    MAC=`ifconfig $EXT_IF | awk '/ether/ { print $2 }'`
    IP=`ifconfig $EXT_IF | awk '/inet / { print $2 }'`
    NETMASK=`ifconfig $EXT_IF | awk '/netmask/ { print $4 }'`

    GW=$GWIP

    if [ -z "$GW" ]
    then
      GW=`ip route show dev $EXT_IF | awk '/default/ { print $3 }'`
    fi

    if [ -z "$GW" ]
    then
      GW=`cat .saved-gateway`
    else
      # Bridging $EXT_IF will make it lose its routes, and I haven't found a better
      # way to preserve it other than saving to a file
      echo $GW > .saved-gateway
    fi

    FLAGS="-d pcall,cpu_reset,guest_errors \
      -netdev tap,id=mynet0 \
      -device rtl8139,netdev=mynet0,mac=$MAC \
      -object filter-dump,id=dp1,netdev=mynet0,file=vm0.pcap"

    set -x

    qemu-system-i386 -s -nographic -kernel kernel/vmpeoz -initrd init.tar $FLAGS $UD_MONITOR \
                     -append "init=/ramfs/bin/nsa ipaddr=$IP netmask=$NETMASK gwipaddr=$GW"
    ;;

  *)
    echo $"Usage: $0 {diskimage|debug|display|vnc|terminal|test-shell|test-cdrom}"
    exit 1
esac
