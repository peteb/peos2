Why build yet another operating system?
---------------------------------------

* Because it's fun (most important point!)
* To learn and improve
* To study algorithms and system design
* It's meditative

General
-------
DON'T IMPLEMENT GRAPHICS. It's a crazy rabbit hole of VESA, VBE3, VGA,
SVGA, etc. especially when the BIOS isn't used. Plus, I've already
played around a lot with graphics -- better to focus on networking
which has far better documentation.

Note: if I want to do graphics, I should probably use the multiboot
video feature. It's incredibly handy, if it works.

Try to make things as simple as possible when taking into account
current requirements -- not what might be needed in the future. Ie,
don't abstract out x86 until multi-platform is needed.

DON'T overthink naming. Ie, don't waste time thinking about "init" vs
"setup", verb-noun vs noun-verb, etc. It doesn't have to be
consistent.

Build and run
-------------
* Build the cross-compiler docker image in build/compiler
* Use build/build-shell to get a bash shell with the cross-compiler and run `make`
* Run with `run-qemu`

Notes
-----
* Kernel isn't started when constructors are run
* IRQs are mapped to start at 0x20 (IRQ_BASE_INTERRUPT)

Plan
----
* DONE Basics (compiler, etc)
* DONE GDT
* DONE IRQs, INTs, keyboard
* DONE Ring 3 execution
* Syscalls different CPL (Ring 3)
* Simple VFS for device drivers (Syscalls)
* Single screen terminal controllable from program through /dev/termN (VFS)
* Multitasking
* Protected memory through paging + high mem kernel
* Update syscalls to work with paging
* Multi screen terminal (Terminal)
* User permissions in VFS
* Ramdisk
* Some way to get a basic FS up with files (user programs, text)
* FS
* Disk support
* QEMU NIC support
* Basic Ethernet
* SMP

Terminal emulation
------------------
At boot, a number of terminals are spawned and mapped to the F1-F12 keys.

Each terminal is controlled using a /dev/termN special file.

Each terminal gets a buffer.

/dev/termN is a stream of bytes "controlling" the terminal. Ie, bytes
should be seen as commands for the terminal to execute.

Special commands to the terminal (such as "move to x, y", "change
color", etc) use escape sequences similar to ANSI.

Special keys from the terminal (such as "left arrow") also use escape
sequences; no extra syscalls are needed to get the special keys.

keyboard.h -> terminal.h -> {user application -> terminal.h ->} screen.h

Why is keyboard.h separate from terminal.h? Because we might want to
report keycodes from other sources: USB, for example.

Why is screen.h separate from terminal.h? To abstract VGA-specific
code.

Start by implementing canonical mode, in terminal.cc.
